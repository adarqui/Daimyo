this book builds:
- https://github.com/SachaG/Microscope

meteor sits between your app's database and its user interface and makes sure that both are kept in sync.
- core feature: automatic synchronisation of data between the client and the server

meteorite:
- wrapper for meteor
- supports third party packages
- npm install -g meteorite
- mrt create <appname>

meteor packages:
- core packages
- smart packages: http://docs.meteor.com/#/full/packages
- local packages: ./packages
- atmosphere smart packages: third party packages listed on atmosphere
- npm packages

meteor subdirs:
./client, ./server, ./public, ./lib, ./collections

load order:
- files in lib are loaded before anything else

"This book is not about CSS. So to avoid slowing you down with styling details, we've decided to make the whole stylesheet available from the start, so you don't need to worry about it ever again."

css:
./client/stylesheets etc
- gets mnified by meteor

deploying:
- meteor deploy myapp.meteor.com

modulus:
- modulus.io
- officially supports meteor

demeteorizer:
- https://github.com/onmodulus/demeteorizer
- converts your meteor app into a standard nodejs app

"in order to come to life, a template needs a manager"
- in meteor, template managers usually contain Template.*..

logs:
meteor logs <app>

collections
===========

collection:
- special data structure that, through publications and subscriptions, takes care of synchronising real-time data to and from each connected user's browser and into the MongoDB

when declared on the client:
Posts = new Meteor.Collection('posts');
- creates a local, in browser cache of the real mongo collection

minimongo:
- meteor's client-side mongo implementation

resetting the db:
- meteor reset

find:
- returns a cursor, which is a reactive data source

fetch:
- transforms the cursor into actual data/array

database everywhere:
- meteor takes a subset of the database and copies it to the client
- sends the actual raw data to the client
- meteor tells the client what subset of data it can access via publications
- just make sure you're only publishing data you want the client to see

    ie, only publishing safe posts:

    Meteor.publish('posts', function() {
     return Posts.find({flagged: false});
    });

DDP:
- distributed data protocol
- spoken over the pubsub system
- think of publication/subscription system as a funnel that transfers data from a server-side (source) collection to a client-side (target) collection

- ddp refs:
- http://2012.realtimeconf.com/video/matt-debergalis

can pass params to subscribe on the client:
    Meteor.subscribe('posts', 'bob-smith');

to dig deeper, use find:
    return Posts.find({...});

levels of control:
- publishing full collections
- publishing partial collections
- publishing partial properties

publishing full collections:
    Meteor.publish('allPosts', function() { return Posts.find(); });

publishing partial collections:
    Meteor.publish('somePosts', function() { return Posts.find({'author':'Tom'});

publishing partial properties:
    Meteor.publish('allPosts', function() {
        return Posts.find({}, {fields: { data: false }});
    });


Routing
=======

this book uses iron-router
- mrt add iron-router
- developed by discover meteor co-author Tom Coleman

router vocabulary

routes:
- a route is the basic building block of routing.
- instructions of where to go when you encounter a url

paths:
- url within the app
- static: /terms_of_service
- dynamic: /posts/xyz
- query params: /search?keyword=meteor

segments:
- the different parts of a path
- delimited by /

hooks:
- actions that you'd like to perform before, after, or during the routing process
- typical example: checking if user has the proper rights before displaying a page

filters:
- global hooks you define for one or more routes

route templates:
- each route points to a template
- if not specified, router picks same name of route by default

layout:
- contain all the html code that wraps the current template
- remains the same if the template changes

controllers:
- if templates are reusing the same parameters, can let routes inherit from a single routing controller which will contain all of the routing logic

{{yield}} helper:
- special dynamic zone that will automatically render whichever template corresponds to the current route

configuring the layout template:
    Router.configure({
     layoutTemplate: 'layout'
    });

{{pathFor}}
- returns the url path component of any route
- instead of specifying static links, use pathFor

     <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>

waitOn:
- good idea to use waitOn
- makes sure subscriptions are available before templates render

within the data function for a specific route, 'this' refers to the currently matched route

by setting a template's data context:
- you can control the value of 'this' inside template helpers

others ways to do it:

    {{#each widgets}}
        {{> widgetItem}}
    {{/each}}

    {{#with myWidget}}
        {{> widgetPage}}
    {{/with}}

    {{> widgetPage myWidget}}

linking to a router, specifying url params:
    {{pathFor 'postPage' someOtherPost}}

url changes are happening using html5 pushState



sessions
========

Session:
- stores ephemeral state that is only relevant to the current user's version of the app
- global reactive data store
- global singleton object
- Session.set('key', 'value');
- Session.get('key')

HCR
- hot code reload
- preserves session variables

autorun:
- automatically runs each time a reactive data source is changed

    Deps.autorun(function() {
        console.log(Session.get('bleh'));
    });

"if we can manage to keep all of our state in the URL and the session, we can transparently change the running source code of each client's application underneath them with minimal disruption"
- obviously, store any state that you want to be shareable between users within the url itself


adding users
============

mrt add accounts-ui-bootstrap-dropdown  or  mrt add accounts-ui
mrt add accounts-password

{{loginButtons align=".."}}

Meteor.users


reactivity
==========

"collections are meteor's core feature, reactivity is the shell that makes that core useful"
- behind the scenes, meteor is able to change any part of your user interface when an underlying collection is updated
- imperative way to do this: use .observe()

.observe()
- imperative way to do it
- a cursor function that fires callbacks when documents matching that cursor change

a declarative approach
- reactivity is a declarative approach
- defined relationships between objects once, they will be kept in sync
- don't have to specify behaviors for every possible change
- behind the scenes, meteor wires up observe() callbacks for us

reactivity is limited to:
- specific areas of your code called 'computations'

computation:
- a block of code that runs every time one of the reactive data sources it depends on changes
- set up via Deps.autorun(function() { });
- autorun creates computations behind the scenes. wires it up to re-evaluate whenever the data sources it depends on change



creating posts
==============

bind events to submit event, not click
- preferred

go()
- constructs a URL

Collection.allow, Collection.deny

hooks:
- intercept the routing process and potentially change the action that the router takes
- hooks are reactive
- for example:

    var requireLogin = function() {
         if (! Meteor.user()) {
         this.render('accessDenied');
         this.stop();
         }
    }

    Router.before(requireLogin, {only: 'postSubmit'});
    ^^ will only allow postSubmit to be called if requireLogin passes

in templates, to see if a user is logged in:
{{#if currentUser}}
- equivalent to Meteor.user()


methods:
- a Collection's insert, update, and remove functions are all methods behind the scenes: Meteor.methods()
- run on the client and server .. aka latency compensation

throwing errors:
- throw new Meteor.Error(code,'message',args);

picking out fields, how they do it:
 // pick out the whitelisted keys
 var post = _.extend(_.pick(postAttributes, 'url', 'title', 'message'), {
     userId: user._id,
     author: user.username,
     submitted: new Date().getTime()
 });
 var postId = Posts.insert(post);
 return postId;


sorting example:
-1 = descending
    return Posts.find({}, {sort: {submitted: -1}});


limiting fields!
- denying the ability to modify critical fields
- using Collection.deny()

    Posts.deny({
        update: function(userId, post, fieldNames) {
            return (_.without(fieldNames, 'url', 'title').length > 0);
        }
    });

latency compensation
--------------------

stub:
- a method simulation that meteor runs on the client in parallel, while the real method is being run on the server

global helpers for 'owns document/owns post etc'??
- registerHelper http://stackoverflow.com/questions/15330515/how-do-i-define-a-global-template-helper-function


allow/deny
----------

meteor starts with all of the deny callbacks, then hits the allow callbacks.
- if an allow callback returns true, operation is permitted
- can use multiple callbacks to clean up the code..

    Posts.allow({update:{..}});
    Posts.allow({update:{...});

using deny as a callback:
- do something, then return false
- can be used to update timestamps etc.. hacky but works

    Posts.deny({
        update: function(userId, doc, fields, modifier) {
             doc.lastModified = +(new Date());
             return false;
        },
        transform: null
    });


errors
======

use local collections
- exist only in the browser
- simply defined in client/

    client/helpers/errors.js

    Errors = new Meteor.Collection(null)

- can create a throwError helper which inserts into errors and updates a 'flash' on the main layout

    throwError = function(message) {
        Errors.insert({message: message, seen: false});
    }

    clearErrors = function() {
        Errors.remove({seen: true});
    }

    main layout:
    {{> errors}}

    errors:
    {{#each errors}}
        {{> error}}
    {{/each}}

    error:
    {{message}}

    template helper:
    Template.errors.helpers({
        errors: function() { Errors.find(); }
    });

    clearing errors on page transitions:
    Router.before(function() { clearErrors(); });

can throw error 'reasons' likethis:
    Meteor.call('post', post, function(error, id) {
        if (error) {
            throwError(error.reason);
        }
    });


Meteor.defer(cb)
- execute the callback 'just after' whatever is going on now
- "like telling the browser to wait 1ms before proceeding"

rendered callback:
- triggers once our template has been rendered in the browser
- triggers every time it's rendered in the browser
- 'this' refers to the current template instance
- this.data accesses the data of the object currently being rendered


creating a meteorite package
============================


