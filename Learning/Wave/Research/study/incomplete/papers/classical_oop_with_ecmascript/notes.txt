ecmascript Object-Oriented paradigm supports two sub-paradigms:
- prototypical
- classical

creation of objects:

    var obj = { foo: "var" };

object literals:
- can be thought of as anonymous singletons
- have no name, identified by the variable to which they are assigned
- only one instance of the literal will exist throughout the life of the software

function createObj() { return { name: "foo" };
createObj() !== createObj(); // true

A singleton with properties and methods:
    var obj = {
        name: "foo"
        setName: function(val) { obj.name = val; }
        getName: function() { return obj.name; }
        ...
    };
    obj.setName('x');
    obj.getName();

re-using objects as prototypes = BAD
- object prototypes would be shared between instances
    function Foo() { };
    Foo.prototype = obj; // obj from above, BAD

each object is expected to have its own state

prototype chain:
- when accessing a property of an object, the member of the obj itself are first checked
- if the member is not defined on the obj itself, the prototype chain is traversed

when a method of an instance's prototype is invoked, 'this' is bound, by default, to a reference of that instance.

    function Foo(name) { this.name = name; }
    Foo.prototype = {
        setName = function(name) { this.name = name; }
        ...
    };
    var inst = new Foo('bar');

method:
- invokable property of an object (a function)

all object members in ecmascript are: public

privileged members:
- functions introduce scope
- allows us to define a local variable (or use an argument) within the constructor that is only accessible to the privileged member (some function)
- severe performance penalty
- if you use privileged members, only use them to access encapsulated data.. otherwise, use prototype
- below: using privileged members to encapsulate data

    function Foo(name) {
        this.getName = function() { return name; }
        this.setName = function(newName) { name = newName; }
    }

    ^^ this method has severe performance issues
    getName/setName defined every instantiation


popular alternative to privileged members:
- prefix members with an underscore: this._name
- rely on trusting people will obey the intent and not use these members directly
- does not truly encapsulate anything

subtypes & polymorphism

subtyping:
- aka subclassing
- act of extending a supertype with additional functionality
- create a child class from a parent
- subtypes inherit members from the supertype

an instance of a subtype can be used in place of any of its supertypes
- polymorphism

polymorphism in ecmascript:

    function getFooName(foo) {
        if (!(foo instanceOf Foo)) { throw TypeError('..'); }
        return foo.getName();
    };

    var inst_parent = new Foo('parent');
    var inst_child = new SubFoo('child');
    getFooName(inst_parent); // "parent"
    getFooName(inst_child); // "child"
    getFooName({}); // TypeError

the further down the protype chain the engine must traverse in order to find a given member, the greater the performace impact.

multiple inheritance:
- unsupported
- each constructor may only have one prototype property
- alternatives such as: interfaces, traits/mixins

Object.getPrototypeOf():
- allows retrieving the prototype of an object (instance)

extensible constructors:

solution to dummy data problem for subtypes:
- check arguments.length
- has several drawbacks: what if arguments are optional? or there are none?

    function Foo(name) {
        if (arguments.length === 0) { return; }
        ...
    }

    SubType.prototype = new Foo(); // ok


ecmascript shortcomings
=======================

access modifiers:
- unsupported
- classical oop permits: public, protected, private
- permit encapsulation without the overhead of privileged members

"in order for a member to be accessible to other objects higher up on the prototype chain (subtypes), they must be:
- public

intuitive subtyping:
- programmer should be thinking about business logic, not prototype puzzles and creating extensible constructors


hacking around prototypal limitations
=====================================

all hacks introduce overhead

extensible constructors revisited:
- pass a function
- have to impliment our own

    var Foo = (function(extending) {
        var F = function(name) {
            if (extending) return;
            ...
        };

        F.asPrototype = function() {
            extending = true;
            var proto = new F();
            extending = false;
            return proto;
        }
        F.prototype = {
            // getName() ..
        };
        return F;
    })(false);

    function SubFoo() { .. }
    SubFoo.prototype = Foo.asPrototype();

    ...



leftoff: page 7
