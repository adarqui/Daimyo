REST:
- architectural style, not standard
- flexible

pragmatic REST
- places success of developer over and above any other design principle
- developer is customer of web api
- success of api design is measured by how quickly developers can get up to speed and start using your API
- primary design principle should be to maximize developer productivity and success

api craft google group:
https://groups.google.com/forum/?fromgroups#!forum/api-craft

questions:
- what are we trying to achieve?

AppUser -> AppStore -> App -> AppDeveloper -> World-of-APIs -> API -> API Team -> Internal Systems

pragmatic rest principles:
- keep simple things simple
    - keep your base URL simple and intuitive
    - only two base urls per resource
        /dogs & /dogs/1234
    - first url is for a collection
    - second url is for a specific element in the collection
- keep verbs out of your base URLs
- use HTTP verbs to operate on the collections and elements

HTTP verbs:
- POST, GET, PUT, DELETE (CRUD)

Resource        POST        GET     PUT     DELETE
                create      read    update  delete
/dogs
/dogs/1234      error


plural nouns and concrete names:
- favor plural
- avoid a mixed model in which you use singular for some resources, plural for others
- favor concrete names instead of abstract: /blogs, /videos, /news instead of /items
- keep number of resources between 12 and 24

simplify associations:
- sweep complexity under the ?
    /dogs/?color=red&blah=blah etc
- resources almost always have relationships to other resources
- shouldn't need to nest deeper than this: /resource/identifier/resource

"dogs belong to owners", "to get all dogs belonging to a specific owner"
- /owners/:id/dogs

handling errors:
- key tool for providing context and visibility into how to use the api
- use HTTP status code, try and map them cleanly to your api errors
- ~10 http status codes for errors:
- 200 201 304 400 401 403 404 409 410 412 500

start with these 3 responses:
- 200 OK
- 400 Bad Request
- 500 Internal Server Error

some more:
- 201 - Created
- 304 - Not Modified
- 404 â€“ Not Found
- 401 - Unauthorized
- 403 - Forbidden

return verbose error messages:
{ "developerMessage": "Verbose...", "userMessage": "Less verbose", "errorCode": 12345, "more_info": "url for more info, https://dev.blah.com/errors/12345" }

extreme programming:
- test first

versioning:
- one of the most important considerations
- never release an API without a version, make it mandatory
- use /vX/ prefix, ie /v1/...
- version should have the highest scope
- use a simple ordinal number, don't use anything with a . (decimal)
- maintain at least one back version
- give developers at least one cycle to react before obsoleting a version
- sticking versions in HTTP headers is more appropriate but less used/easy to work with

header versioning logic:
- "if it changes the logic you write to handle the response, put it in the URL so you can see it easily"
- "if it doesn't change the logic for each response, like oauth, put it in the header"

versioning cases:
- don't do like twilio/salesforce/facebook:
- twilio: /<date>/...
- salesforce.com: /services/data/v1.0/sobjects/<data>
- facebook.com: /...?v=1.0
- the logic behind the interface can change rapidly, but the interface itself shouldn't change frequently

"This is problematic because as soon as Facebook forced the API up to the next version, all
the apps that didn't include the version number broke and had to be pulled back and
version number added."

handle different response formats:
dogs/1
Content-Type: application/json
dogs/1
Content-Type: application/xml
dogs/1
Content-Type: application/png

partial response:
- google pioneered partial response

partial response cases:
- linkedin: /people:(id,first-name,...)
- facebook: /joe.smith/friends?fields=id,first-name
- google: /joe.smith?fields=id,first-name

recommendation:
/dogs?fields=name,color

pagination:
- make it easy for devs to paginate objects in a db
- recommendation: use limit and offet
- defaults: limit=10, offset=0

pagination cases:
- facebook: offset, limit
- twitter: rpp (request per page)
- linkedin: start, count

/dogs?limit=25&offset=50

metadata:
- recommend including metadata with each response that is paginated, tell the total number of records available

responses that don't involve resources:
- for example: calculate, translate, convert
- use verbs, not nouns
- make it clear that these are "non resources"
- make itclear to use verbs in cases like these
- these calculate something, not simply returning data from a resource

formats:
- support more than one format
- recommendation: four square approach: use 'extension' to specify a format
- /dogs/1234.json, /dogs.json

default formats: json

format cases:
- google: ?alt=json
- 4square: .../venue.json
- digg: 2 ways: Accept: application/json ... ?type=json

attribute names:
- recommendation: 4square
- follow javascript naming conventions
- CamelCase

attribute cases:
- twitter: created_at
- bing: DateTime
- 4square: createdAt: unixtimestamp

global search:
/search?q=blah

scoped search:
/owners/5678/dogs?q=blah

consolidate api requests in one subdomain:
- api.blah.com
- redirect non api requests to the developer portal:

developer portal:
- dev.blah.com
- developers.blah.com

authentication:
- use oauth2.0
- web and mobile apps that expose api's don't have to share passwords
- allows api provider to reboke tokens for an individual user, for an entire app, without requiring the user to change their original password

consider building an sdk
- can reduce inefficient/unsafe code/requests

api anti pattern: build up approach
- dev exposes core objects of a big system and puts an XML parsing layer on top
- exposes internal architecture details
- inflexible 1:1 mapping

api anti patterns: standards committee approach
- can be very slow
- can lead to mediocre design as a result of too many compromises

api anti pattern: the copy cat approach
- copying someone elses api

api facade pattern
- product manager is a key member of your api team
- comprehensive view of what the api should be, from the dev/user perspective
- "use the facade pattern when you want to provide a simple interface to a complex subsystem. Subsystems often get more complex as they evolve."
- facade handles common patterns: pagination, queryes, ordering, sorting, authentication, authorization, versioning etc
- three step approaches decomposes one big problem into three smaller problems
- three steps:
    1. design the ideal api: urls, req params & responses, payloads, headers, query params
    2. implement the design with data stubs.
    3. mediate or integrate between the facade and the systems.

ideal design -> api facade -> mediate -> backends

