doSomething().then(function () {
  return doSomethingElse();
}).then(finalHandler);

doSomething
|-----------------|
                  doSomethingElse(undefined)
                  |------------------|
                                     finalHandler(resultOfDoSomethingElse)
                                     |------------------|




doSomething().then(function () {
  doSomethingElse();
}).then(finalHandler);

doSomething
|-----------------|
                  doSomethingElse(undefined)
                  |------------------|
                  finalHandler(undefined)
                  |------------------|




doSomething().then(doSomethingElse());

doSomething
|-----------------|
doSomethingElse(undefined)
|---------------------------------|
                  finalHandler(resultOfDoSomething)
                  |------------------|




doSomething().then(doSomethingElse);

doSomething
|-----------------|
                  doSomethingElse(resultOfDoSomething)
                  |------------------|
                                     finalHandler(resultOfDoSomethingElse)
                                     |------------------|




the real problem with callbacks:
- deprive us of return, throw, the stack, etc

promises:
- exposed as window.Promise

composing promises:
-------------------
remotedb.allDocs(...).then(function (resultOfAllDocs) {
  return localdb.put(...);
}).then(function (resultOfPut) {
  return localdb.get(...);
}).then(function (resultOfGet) {
  return localdb.put(...);
}).catch(function (err) {
  console.log(err);
});

most people use forEach when they intend to use all

forgetting to add catch:
- never forget to add catch!
- use this pattern:

somePromise().then(function () {
  return anotherPromise();
}).then(function () {
  return yetAnotherPromise();
}).catch(console.log.bind(console)); // <-- this is badass


*** don't use deferred! ***


somePromise().then(function () {
  // I'm inside a then() function!
});
What can we do here? There are three things:

return another promise
return a synchronous value (or undefined)
throw a synchronous error

I make it a personal habit to always return or throw from inside a then() function. I'd recommend you do the same.


throw/catch:

getUserByName('nolan').then(function (user) {
  if (user.isLoggedOut()) {
    throw new Error('user logged out!'); // throwing a synchronous error!
  }
  if (inMemoryCache[user.id]) {
    return inMemoryCache[user.id];       // returning a synchronous value!
  }
  return getUserAccountById(user.id);    // returning a promise!
}).then(function (userAccount) {
  // I got a user account!
}).catch(function (err) {
  // Boo, I got an error!
});

resolve:
- Promise.resolve(someSynchronousValue).then(/* ... */);

reject:
- Promise.reject(new Error('some awful error'));

always pass a function into then.



