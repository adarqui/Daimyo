source: http://www.incubodc.com/eventos_energia_mayorista/memorias_SG/sg_2011/5_materialadicionalUML/Booch-UML-UserGuide.pdf

uml: graphical language for..
- visualizing
- specifying
- constructing
- and documenting the artifacts of a software-intensive system.
- used to model conceptual and concrete things

conceptual things:
- business processes & system functions

concrete things:
- classes
- database schemas
- reusable software components

analysts and end users:
- who specify the required structure and behavior of a system

architects:
- who design systems that satisfy those requirements

developers:
- who turn those architectures into executable code

quality assurance personnel:
- who verify and validate the system's structure and behavior

librarians:
- who create and catalogue components

project and program managers:
- who generally wrestle with chaos
- provide leadership and direction
- orchestrate the resources necessary to deliver a successful system

As we began our unification, we established three goals for our work:
1. To model systems, from concept to executable artifact, using object- oriented techniques
2. To address the issues of scale inherent in complex, mission-critical systems
3. To create a modeling language usable by both humans and machines


Ch1: Why we Model
=================

successful software organization:
- one that consistently eploys quality software that meets the needs of its users

to develop software of lasting quality:
- you have to craft a solid architectural foundation that's resilient to change

modeling: central part of all activities that lead up to the deployment of good software

build models to:
- communicate the desired structure & behavior of the system
- visualize and control the system's architecture
- better understand the system we are building
- manage risk

dog house vs human house vs high rise:
If you want to build a dog house, you can pretty much start with a pile of lumber, some nails, and a few basic tools, such as a hammer, saw, and tape measure. In a few hours, with little prior planning, you'll likely end up with a dog house that's reasonably functional, and you can probably do it with no one else's help. As long as it's big enough and doesn't leak too much, your dog will be happy. If it doesn't work out, you can always start over, or get a less demanding dog.  If you want to build a house for your family, you can start with a pile of lumber, some nails, and a few basic tools, but it's going to take you a lot longer, and your family will certainly be more demanding than the dog. In this case, unless you've already done it a few dozen times before, you'll be better served by doing some detailed planning before you pound the first nail or lay the foundation.
..
If you want to build a high-rise office building, it would be infinitely stupid for you to start with a pile of lumber, some nails, and a few basic tools.

If you want to keep building buildings, then you will want to be certain to balance the desires of your tenants with the realities of building technology, and you will want to treat the rest of your team professionally, never placing them at any risk or driving them so hard that they burn out.

**Curiously, a lot of software development organizations start out wanting to build high rises but approach the problem as if they were knocking out a dog house.**

Given the increasing demand to develop software in Internet time, development teams often fall back on the only thing they really know how to do wellâ€¢ pound out lines of code. Heroic programming efforts are legend in this industry, and it often seems that working harder is the proper reaction to any crisis in development.

the trick is in creating the right software and in figuring out how to write less software.

model: simplification of reality
- provides the blueprints of a system
- semantically closed abstraction of the system
- can be structural or behavioral

structural model: emphasizing the organization of the system
behavioral model: emphasizing the dynamics of the system

one fundamental reason to model: so that we can better understand the system we are developing

we build models of complex systems because we cannot comprehend such a system in its entirety.

most software organizations do little if any formal modeling.


Principles of Modeling
----------------------

1. The choice of what models to create has a profound influence on how a problem is attacked and how a solution is shaped.
2. Every model may be expressed at different levels of precision.
3. The best models are connected to reality.
4. No single model is sufficient. Every nontrivial system is best approached through a small set of nearly independent models.

"object oriented modeling is superior in crafting resilient architectures"


Object-Oriented Modeling
------------------------

two ways to approach a mode:
- algorithmic
- object-oriented

systems built with an algorithmic focus turn out to be very hard to maintain

object-oriented perspective:
- main building block is the object or class

object: thing
- has identity, state, and behavior
- identity: you can distinguish it from other objects
- state: data associated with it
- behavior: do things to the object and it can do things to other objects

class: desciption of a set of common objects



Ch2: Introducing UML
====================
