source:
- https://wiki.haskell.org/All_About_Monads
- http://web.archive.org/web/20061211101052/http://www.nomaware.com/monads/html/index.html
- https://github.com/dag/all-about-monads

monad:
- way to structure computations in terms of values and sequences of computations using those values
- the monad determines how combined computations form a new computation
- strategy for combining computations into more complex computations

three properties that make monads especially useful:
- modularity: allow computations to be composed from simpler computations & separate combination strategy from the actual computations being performed.
- flexibility
- isolation: can be used to create imperative style computational structures which remain safely isolated from the main body of the functional program.

type constructor:
- parameterized type definition used with polymorphic types
- by supplying a type constructor with one or more concrete types, you can construct a new concrete type

data Maybe a = Nothing | Just a
- type constructor: Maybe
- data constructors: Nothing, Just

construct data values by using a data constructor
- country = Just "USA"

construct types using type constructors
- lookupAge :: DB -> String -> Maybe Int

"m a" represents:
- a container of some type holding a value of some type

if you get kind errors when working with monads:
- it means you're not using the type constructors correctly

monad consists of:
- a type constructor (call it m)
    data m a = ...
- return: a function that builds values of that type (a -> m a)
    return :: a -> m a
- bind: a function that combines values of that type with computations that produce values of that type to produce a new computation for values of that type (m a -> (a -> m b) -> m b)
    ^^ note: container is the same but contents of the container can change
    - the >>= function takes the value from a monad container and passes it to a function to produce a monad container containing a new value, possibly of a different type
    - by adding logic to the binding function, a monad can implement a specific strategy for combining computations in the monad.
    (>>=) :: m a -> (a -> m b) -> m b

it is customary to call the monad type constructor "m" when discussing monads.

"the type constructor m is a container that can hold different values of a".

-- comb is a combinator for sequencing operations that return Maybe
comb :: Maybe a -> (a -> Maybe b) -> Maybe b
comb Nothing  _ = Nothing
comb (Just x) f = f x


Monad Class
-----------

not necessary to make your monads instances of the Monad class, but it is a good idea.
- communicates important information to others who read code
- a function of: doSomething :: (Monad m) => a -> m b .. is much more flexible than: doSomething :: a -> Maybe b
- any instance of the Monad class can be used in a do block.

standard Monad class definition:
class Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    return :: a -> m a

do notation:
x <- expr1
becomes
expr1 >>= \x ->

expr2
becomes
expr2 >>= \_ ->

Maybe
-----

instance Monad Maybe where
    Nothing >>= f = Nothing
    (Just x) >>= f = f x
    return         = Just -- return x = Just x



Monad Laws
----------

monad axioms:
- not enforced by the haskell compiler
- haskell programmer must ensure that any Monad instances declare these axioms
- any type constructor with return and bind operators that satisfy the three monad laws is a monad

three fundamental laws: MINIMAL COMPLETE DEFINITION
- algebraic properties of monads
- return is a left and right identity
- bind is associative
(return x) >>= f == f x
m >>= return == m
(m >>= f) >>= g == m >>= (\x -> f x >>= g)

other rules:
fail
>> :: m a -> m b -> m b
m >> k = m >>= (\_ -> k)


No Way Out
----------

monads allow one-way flow: such as IO monad
- values can enter the monad through return (and sometimes fail)
- allow computations to be performed within the monad using >>= and >>
- DO NOT allow values back OUT of the monad

IMP

The wonderful feature of a one-way monad is that it can support side-effects in its monadic operations but prevent them from destroying the functional properties of the non-monadic portions of the program.

So a one-way monad effectively creates an isolated computational domain in which the rules of a pure functional language can be relaxed. Functional computations can move into the domain, but dangerous side-effects and non-referentially-transparent functions cannot escape from it.

Another common pattern when defining monads is to represent monadic values as functions. Then when the value of a monadic computation is required, the resulting monad is "run" to provide the answer.


Zero and Plus
-------------

mzero & mplus:
1. mzero >>= f == mzero
2. m >>= (\x -> mzero) == mzero
3. mzero `mplus` m == m
4. m `mplus` mzero == m

class (Monad m) => MonadPlus m where
    mzero :: m a
    mplus :: m a -> m a -> m a

instance MonadPlus Maybe where
    mzero             = Nothing
    Nothing `mplus` x = x
    x `mplus` _       = x


