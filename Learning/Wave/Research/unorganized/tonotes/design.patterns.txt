GoF design patterns
- source: http://www.usp.br/thienne/coo/material/GoFDesignPatterns.pdf

* Creational Design Patterns
- http://en.wikipedia.org/wiki/Creational_pattern
- deal with object creation mechanisms
- ways to instantiate
- "hardcoding the actual instantiation is a pitfall and should be avoided if reuse and changeability are desired"

* Creation Pattern: Factory Pattern
- Definition
The Factory pattern provides a way to use an instance as a object factory.
The factory can return an instance of one of several possible classes (in a
subclass hierarchy), depending on the data provided to it.
- Where to use
•When a class can't anticipate which kind of class of object it must create.
•You want to localize the knowledge of which class gets created.
•When you have classes that is derived from the same subclasses, or they
may in fact be unrelated classes that just share the same interface. Either
way, the methods in these class instances are the same and can be used
interchangeably.
•When you want to insulate the client from the actual type that is being
instantiated.
- Benefits
•The client does not need to know every subclass of objects it must create. It
only need one reference to the abstract class/interface and the factory
object.
•The factory encapsulate the creation of objects. This can be useful if the
creation process is very complex.
- Drawbacks/consequences
•There is no way to change an implementing class without a recompile.


AbstractFactory Pattern
Definition
The Abstract Factory pattern is a creational pattern which is related to the
Factory Method pattern, but it adds another level of abstraction. What this
means is that the pattern encapsulates a group of individual concrete factory
classes (as opposed to concrete factory methods which are derived in
subclasses) which share common interfaces. The client software uses the
Abstract Factory which provides an interface for creating families of related
or dependent objects without specifying their concrete classes. This pattern
separates the implementation details of a set of objects from its general
usage.
Where to use
The pattern can be used where we need to create sets of objects that share a
common theme and where the client only needs to know how to handle the
abstract equivalence of these objects, i.e. the implementation is not
important for the client. The Abstract Factory is often employed when there
is a need to use different sets of objects and where the objects could be
added or changed some time during the lifetime of an application.
Benefits
Use of this pattern makes it possible to interchange concrete classes without
changing the code that uses them, even at runtime.
Drawbacks/consequences
As with similar design patterns, one of the main drawbacks is the possibility
of unnecessary complexity and extra work in the initial writing of the code.



Builder Pattern
Definition
The Builder pattern can be used to ease the construction of a complex object
from simple objects. The Builder pattern also separates the construction of a
complex object from its representation so that the same construction process
can be used to create another composition of objects.
Related patterns include Abstract Factory and Composite.
Where to use
•When the algorithm for creating a complex object should be independent of
the parts that make up the object and how they are assembled.
•When the construction process must allow different representations for the
object that is constructed.
•When you want to insulate clients from the knowledge of the actual
creation process and/or resulting product.
Benefits
•The built object is shielded from the details of its construction.
•Code for construction is isolated from code for representation and both are
easy to replace without affecting the other.
•Gives you control over the construction process.
•Gives you the possibility to reuse and/or change the process and/or product
independently.
Drawbacks/consequences
Need flexibility in creating various complex objects. Need to create complex,
aggregate objects


Prototype Pattern
Definition
The Prototype pattern is basically the creation of new instances through
cloning existing instances. By creating a prototype, new objects are created
by copying this prototype.
Where to use
•When a system needs to be independent of how its objects are created,
composed, and represented.
•When adding and removing objects at runtime.
•When specifying new objects by changing an existing objects structure.
•When configuring an application with classes dynamically.
•When keeping trying to keep the number of classes in a system to a
minimum.
•When state population is an expensive or exclusive process.
Benefits
•Speeds up instantiation of large, dynamically loaded classes.
•Reduced subclassing.
Drawbacks/consequences
Each subclass of Prototype must implement the Clone operation. Could be
difficult with existing classes with internal objects with circular references or
which does not support copying.


Singleton Pattern
Definition
The Singleton pattern provides the possibility to control the number of
instances (mostly one) that are allowed to be made. We also receive a global
point of access to it (them).
Where to use
When only one instance or a specific number of instances of a class are
allowed. Facade objects are often Singletons because only one Facade object
is required.
Benefits
•Controlled access to unique instance.
•Reduced name space.
•Allows refinement of operations and representations.
Drawbacks/consequences
Singleton pattern is also considered an anti-pattern by some people, who feel
that it is overused, introducing unnecessary limitations in situations where a
sole instance of a class is not actually required.


Small example
package com.logica.singleton;
public class FileLogger {
private static FileLogger logger;
// Prevent clients from using the constructor
private FileLogger() {
}
//Control the accessible (allowed) instances
public static FileLogger getFileLogger() {
if (logger == null) {
logger = new FileLogger();
}
return logger;
}
public synchronized void log(String msg) {
// Write to log file...
}
}



Structural design patterns
==========================

In software engineering, structural design patterns are design patterns
that ease the design by identifying a simple way to realize relationships
between entities.


Structural Patterns describe how objects and classes can be combined to
form structures. We distinguish between object patterns and class patterns.
The difference is that class patterns describe relationships and structures
with the help of inheritance. Object patterns, on other hand, describe how
objects can be associated and aggregated to form larger, more complex
structures.


Adapter Pattern
Also known as Wrapper.
Definition
The Adapter pattern is used to translate the interface of one class into
another interface. This means that we can make classes work together that
couldn't otherwise because of incompatible interfaces. A class adapter uses
multiple inheritance (by extending one class and/or implementing one or
more classes) to adapt one interface to another. An object adapter relies on
object aggregation.
Where to use
•When you want to use an existing class, and its interface does not match
the one you need.
•When you want to create a reusable class that cooperates with unrelated or
unforeseen classes, that is, classes that don't necessarily have compatible
interfaces.
•When you want to increase transparency of classes.
•When you want to make a pluggable kit.
Benefits
•Highly class reusable.
•Introduces only one object
Drawbacks/consequences
When using Java, Target must be an interface.



Bridge Pattern
Definition
Decouple an abstraction or interface from its implementation so that the two
can vary independently.
Bridge makes a clear-cut between abstraction and implementation.
Where to use
•When you want to separate the abstract structure and its concrete
implementation.
•When you want to share an implementation among multiple objects,
•When you want to reuse existing resources in an 'easy to extend' fashion.
•When you want to hide implementation details from clients. Changes in
implementation should have no impact on clients.
Benefits
Implementation can be selected or switched at run-time. The abstraction and
implementation can be independently extended or composed.
Drawbacks/consequences
Double indirection - In the example, methods are implemented by subclasses
of DrawingAPI class. Shape class must delegate the message to a DrawingAPI
subclass which implements the appropriate method. This will have a slight
impact on performance.


Composite Pattern
Definition
The Composite pattern helps you to create tree structures of objects without
the need to force clients to differentiate between branches and leaves
regarding usage. The Composite pattern lets clients treat individual objects
and compositions of objects uniformly.
Where to use
•When you want to represent a part-whole relationship in a tree structure.
•When you want clients to be able to ignore the differences between
compositions of objects and individual objects.
•When the structure can have any level of complexity and is dynamic.
Benefits
•Define class hierarchies consisting of primitive objects and composite
objects.
•Makes it easier to add new kind of components.
Drawbacks/consequences
The Composite pattern makes it easy for you to add new kinds of components
to your collection as long as they support a similar programming interface. On
the other hand, this has the disadvantage of making your system overly
general. You might find it harder to restrict certain classes where this would
normally be desirable



Decorator Pattern
Definition
The Decorator pattern lets you attach additional responsibilities and modify
an instance functionality dynamically. Decorators provide a flexible
alternative to subclassing for extending functionality, using composition
instead of inheritance.
Where to use
•When you want to add responsibilities to individual objects dynamically and
transparently, without affecting the original object or other objects.
•When you want to add responsibilities to the object that you might want to
change in the future.
•When extension by static subclassing is impractical.
Benefits
•More flexibility than static inheritance.
•Avoids feature-laden classes high up in the hierarchy.
•Simplifies coding because you write a series of classes each targeted at a
specific part of the functionality rather than
•coding all behavior into the object.
•Enhances the object's extensibility because you make changes by coding
new classes.
Drawbacks/consequences
One thing to keep in mind when implementing the Decorator pattern is that
you need to keep the component interface simple. You want to avoid making
the component interface overly complex, because a complex interface will
make it that much harder to get each decorator right.
Another potential drawback of the Decorator pattern is the performance
overhead associated with a long chain of decorators.



Facade Pattern
Definition
This design pattern provides a unified interface to a set of interfaces in a
subsystem. It defines a higher-level interface that makes the subsystem
easier to use. A facade is an object that provides a simplified interface to a
larger body of code, such as a class library.
Where to use
The Facade can be used to make a software library easier to use and
understand, since the Facade has convenient methods for common tasks. For
the same reason, it can make code that uses the library more readable. The
pattern can also be used to reduce dependencies of outside code on the
inner workings of a library, since most code uses the Facade it allows more
flexibility when developing the system. A final usage scenario is where we
can wrap several poorly-designed APIs with a single well-designed API.
Benefits
The main benefit with the Facade pattern is that we can combine very
complex method calls and code blocks into a single method that performs a
complex and recurring task. Besides making code easier to use and
understand, it reduces code dependencies between libraries or packages,
making programmers more apt to consideration before writing new code that
exposes the inner workings of a library or a package. Also, since the Facade
makes a weak coupling between the client code and other packages or
libraries it allows us vary the internal components since the client does not
call them directly.
Drawbacks/consequences
One drawback is that we have much less control of what goes on beyond the
surface. Also, if some classes require small variations to the implementation
of Facade methods, we might end up with a mess.


Flyweight Pattern
Definition
Th Flyweight pattern provides a mechanism by which you can avoid creating
a large number of 'expensive' objects and instead reuse existing instances to
represent new ones.
Where to use
•When there is a very large number of objects that may not fit in memory.
•When most of an objects state can be stored on disk or calculated at
runtime.
•When there are groups of objects that share state.
•When the remaining state can be factored into a much smaller number of
objects with shared state.
Benefits
Reduce the number of objects created, decrease memory footprint and
increase performance.
Drawbacks/consequences
Designing objects down to the lowest levels of system "granularity" provides
optimal flexibility, but can be unacceptably expensive in terms of
performance and memory usage.



Leftoff: Proxy Pattern
