Introduction
------------

The concept of patterns and pattern languages was originally applied to city and building architecture by Christopher Alexander in his seminal works A Pattern Language and A Timeless Way of Building.

pattern language:
- web of related patterns where each pattern leads to others, guiding the reader through the decision making process.
-  teaches the reader how to solve a limitless variety of problems within a bounded problem space. 

fundamental new challenges:
- networks are unreliable
- networks are slow
- any two applications are different
- change is inevitable
    - An integration solution needs to minimize the dependencies from one system to another by using loose coupling between applications. 

^^ developers overcome these challenges in four main approaches:
- File transfer
- Shared database
- Remote procedure invocation
- Messaging

"This book is about how to use messaging to integrate applications"

think of messaging like:
- telephone system: synchronous -> can only communicate when the party is on the other end
- voice mail: asynchronous -> easier than trying to get the caller/receiver on the phone at the same time. receiver can listen at his convenience.

Messaging is a technology that enables high-speed, asynchronous, program-to-program communication with reliable delivery

channels aka queues
- logical pathways that connect programs and convery messages

sender or producer
- sends a message to a channel

receiver or consumer
- receives a message by reading (and deleting) it from a channel

message contains:
- header: metadata about the message -> who sent, where it's going etc
    - ignored by applications
- body: data
    - ignored by the messaging system  

messaging capabilities provided by:
- messaging system
- message oriented middleware (MOM)

The primary purpose of a database is to make sure each data record is safely persisted, and likewise the main task of a messaging system is to move messages from the sender’s computer to the receiver’s computer in a reliable fashion. 

IMP
The reason a messaging system is needed to move messages from one computer to another is that
computers and the networks that connect them are inherently unreliable. Just because one application is ready to send a communication does not mean that the other application is ready to
receive it. Even if both applications are ready, the network may not be working, or may fail to
transmit the data properly. 

a message is transmitted in 5 steps:
- create: sender creates the message and populates it with data
- send: sender adds the message to a channel
- deliver: the messaging system moves the message from the sender’s computer to the receiver’s computer, making it available to the receiver.
- receive: receiver reads the message from the channel
- process: receiver extracts the data from the message

send and forget:
- sending application sends the message to the msg channel
- once complete, sender goes on to other work
- message system transmits the message in the background
- sender can be confident that the receiver will eventually receive the message and DOES NOT HAVE TO WAIT UNTIL THAT HAPPENS.

store and forward:
- when the sending application sends the message to the message channel, the messaging system stores the message on the sender’s computer, either in memory or on disk. In step 3, the messaging system delivers the message by forwarding it from the sender’s computer to the receiver’s computer, and then stores the message once again on the receiver’s computer.

Why use messaging? The quick answer:
- messaging is more immediate than File Transfer, better encapsulated than Shared Database, and more reliable than Remote Procedure Invocation. However, that’s just the beginning of the advantages that can be gained using messaging. 
- remote communication: can't share data, must serialize and send over the wire
- platform/language integration: allow services written in different languages/technologies to communicate. common message paradigm.
- asynchronous communication: send and forget approach to communication. sender only needs to wait for the message to be sent to the message system.
- variable timing:
    - with synchronous communication: caller must wait for the receiver to finish processing the call before the caller can receive the result and continue. CALLER CAN ONLY MAKE CALLS AS FAST AS THE RECEIVER CAN PERFORM THEM.
    - with asynchronous communication: allows the sender to batch requests to the receiver at its own pace, and for the receiver to consume the requests at its own different pace. ALLOWS FOR MAXIMUM THROUGHPUT AND NOT WAITING ON EACH OTHER.
- throttling: async communication enables the receiver to control the rate at which it consumes requests, so as not to become overloaded
- reliable communication: messaging uses STORE AND FORWARD approach, whilst RPC does not.- 
- disconnected operation: for applications that run disconnected from the network, messages can be queues, application connects, consumes queue, and disconnects
- mediation: messaging systems acts as a mediator: mediator pattern. sits in the middle, can be redundant and highly available
- thread management: callbacks vs threads. async allows you to use callbacks.

Challenges of asynchronous messaging:
- complex programming model: event-driven programming model. app logic can no longer be coded in a single method. inherently more complex.
- sequence issues: channels guarantee message deliver, but not the order or when the message will be delivered.
- synchronous scenarios: not all apps can operate in send and forget mode.
- performance: messaging systems add some overhead.
- limited platform support: proprietary msg systems not available on all platforms.
- vendor lock-in: many msg system implementations rely on proprietary protocols. "integrating multiple integration solutions"

important:
Performance. Messaging systems do add some overhead to communication. It takes effort
to make data into a message and send it, and to receive a message and process it. If you
have to transport a huge chunk of data, dividing it into a gazillion small pieces may not
be a smart idea. For example, if an integration solution needs to synchronize information
between two exiting systems, the first step is usually to replicate all relevant information
from one system to the other. For such a bulk data replication step, ETL (extract,
transform, and load) tools are much more efficient than messaging. Messaging is best
suited to keeping the systems in sync after the initial data replication. 

synchronous calls imply that the calling process is halted while the sub-process is executing a function.

"This book is about enterprise integration—how to integrate independent applications so that they can work together."

enterprise application often incorporates an n-tier architecture: more sophisticated version of cli/serv arch
- this is application distribution not application integration.
- because:
    communicating parts are tightly coupled - they depend directly on each other.
    one tier cannot function without the others.
    communication tends to be synchronous

integrated applications:
- independent applications that can each run by itself
- coordinate with each other in a loosely coupled way
- focus on one comprehensive set of functionality yet delegate to other applications for related functionality
- don't have to wait for a response
- tend to have a broad time constraint

messaging vendor products grouped into the following four categories:
- operating systems: MSMQ
- application servers: JMS
- EAI suites: TIBCO
- web service toolkits: WS-Reliability

For a reader to truly learn from a pattern, it has to document why the problem is difficult to solve, consider possible solutions that in fact don’t work well, and explain why the solution offered is the best available. 

Alexandrian form: We used a style that is fairly close to the Alexandrian form, which was first popularized for computer programming in Smalltalk Best Practice Patterns by Kent Beck.


pattern language structure:
- name
- icon
- context
- problem
- forces
- solution
- sketch
- results
- next
- sidebars
- examples

Next – This section lists other patterns to be considered after applying the current one.
Patterns don’t live in isolation; the application of one pattern usually leads you to new
problems that are solved by other patterns. This is what makes the collection a pattern
language and not just a pattern catalog.

integration solutions consist of:
- many different pieces—applications, databases, endpoints, channels, messages, routers, etc

UMLEAI - UML profile for EAI (enterprise application integration)

MDA - model driven architecture

nice quote:
Starting with a pattern in the middle of the language can be like starting to watch a movie that’s half over; you see what’s happening but don’t understand what it means. 

The root patterns in this language are:
• Messaging – This is the #1 root pattern for the entire book: What is messaging, what
problem does it solve, and how does it solve it?
• Message Channel – What is the structure in a messaging system that conveys messages
from the sender to the receiver? How do you know which ones your applications need?
• Message – How does information get communicated from a sender to a receiver?
• Pipes and Filters – How can intermediate steps be performed after a message is sent but
before it is received?
• Message Router – If the sender does not know ultimately where the message should go,
how can the messaging system get it there?
• Message Translator – If the sender and receiver do not agree on the message format, how
can they communicate?
• Message Endpoint – How do the applications that send and receive messages connect to
the messaging system? 


