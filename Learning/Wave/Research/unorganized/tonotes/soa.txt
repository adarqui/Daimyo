source: http://www.sei.cmu.edu/library/assets/whitepapers/SOA_Terminology.pdf

Ch1
===

SOA:
- services provide reusable business functionality via well-defined interfaces
- clear separation between service interface and service implementation
- service consumers are built using functionality from available services
- SOA enables discovery, composition, invocation of services
- protocols are predominantly, but not exclusively, message based document exchanges

services:
- reusable components that represent business or operational tasks
- reuseable = key
- services expose capabilities via well-defined standard service interfaces
- service interface definitions are available in a service registry

service implementation:
- corresponds to the actual system capabilities that implement the service interface
- separation of interface and implementation
- service interfaces hide the complexity and diversity of service implementations from consumers

SOA infrastructure:
- set of technologies that bind service consumers to services through an agreed upon communication model (MOM, pubsub, CORBA etc)

service consumers:
- clients of the provided services


Three basic operations to support SOA
-------------------------------------
1. Service Discovery - consumers become aware of available services and their capabilities
    - service provider publishes its service in some form of service registry
2. Service Composition - mechanism by which services are combined to fulfill a business or operational process.
3. Service Invocation - mechanism by which services are invoked by service consumers at runtime.
    - point-to-point: service consumers directly invoke services over a network
    - mediated: service consumers invoke services via a middlware component such as an enterprise service bus (ESB)

implementation:
- WS (web services) - soap etc
- REST

REST:
- simplified version of WS
- every entity can be identified, named, or handled is considered a resource that is addressable by using a URI
- consumers communicate with services via GET, POST, PUT, DELETE
- simplicity

ESB (Enterprise Service Bus)
- middleware product that connects and mediates all communications and interactions between service consumers and services, usually based on standards
- reduces complexity by connecting services with their consumers by implementing VETRO pattern

VETRO:
- Message -> Validate -> Enrich -> Transform -> Route -> Operate

"SOA is currently the best option available for systems integration and the leveraging of legacy systems. "




Ch 2: Organizing Domain Logic
=============================

three primary patterns:
- transaction script
- domain model
- table module

transactional script:
- simplest approach to storing domain logic
- procedure that takes input from presentation, processes it with validatins and calculations, stores data in db, invokes any operations from other systems.
- then replies with more data to presentation

transactional script: ADVANTAGES
- simple procedural model that most devs understand
- works well with simple data source layer using "Row Data Gateway" or "Table Data Gateway"
- easy to set transcation boundaries: TRANSACTION ... COMMIT

transactional script: DISADVANTAGES
- duplicated code
- tangled web of routines without a clear structure

IMP
domain model:
- OO way
- build a model of our domain, first approximation organized primarily around nouns of the domain
- once you've gotten used to things, many techniques that allow you to handle incresingly complex logic in a well organized way
- cost comes from complexity o using it and complexity of data source layer
- the richer your domain model, the more complex your mapping to a relational database

"Using a Domain Model (116) as opposed to a Transaction Script (110) is the essence of the paradigm shift that object-oriented people talk about so much. Rather than one routine having all the logic for a user action, each object takes a part of the logic that's relevant to it."

transactional script vs domain model diagram: Figure 2.2, Figure 2.2, page 40
- "The essential problem is that different kinds of product have different algorithms for recognizing revenue on a given contract"

table module:
- designed to work with a record set
- middle ground between transactional script and domain model

Making a choice
- with simple domain logic, the domain model is less attractive because the cost of understanding it and the complexity of the data source add a lot of effort to developing it that won't be paid back

IMP
"your problem, of course, is to figure out where on that x acis your application lies"
- x axis = complexity of domain logic
- y axis = effort to enhance


Service Layer
-------------

common approach to handling domain logic:
- split domain layer in two
- Service Layer is placed over an underlying Domain Model or Table Module
- presentation logic interacts with the domain purely through the Service Layer (api)

Service Layer
- good place to put transaction control and security
- how much behavior to put in?
- minimal case: make it a facade -> all real behavior is in underlying objects. All the service layer does is forward calls on the facade to lower-level objects.
- extreme: most business logic is placed in Transactional Scripts inside the Service Layer.

Controller-Entity Style:
- logic that's particular to a single transaction or use case placed in Transactional Scripts which are commonly referred to as controllers or services.
- behavior that's used in more than one use case goes on the domain objects called entities
- encourage duplicate code

domain objects = entities

"my preference is to have the thinnest service layer you can, if you need one"


Ch 3: Mapping to Relational Databases
=====================================
