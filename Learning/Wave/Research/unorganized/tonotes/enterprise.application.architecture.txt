The business "logic" rarely fits any logical pattern, because, after all, it's written by business people to capture business, where odd small variations can make all the difference in winning a deal. Each of those little victories adds yet more complexity to the system.

That's the kind of thing that gets me excited: how to take all that complexity and come up with a system of
objects that can make the problem more tractable. Indeed, I believe that the primary benefit of objects is in
making complex logic tractable. Developing a good Domain Model (116) for a complex business problem is
difficult but wonderfully satisfying.

Enterprise applications are about the display, manipulation, and storage of large amounts of often complex data and the support or automation of business processes with that data.

In building software I'm a great believer in iterative development.

At the heart of iterative development is the notion that you should deliver software as soon as you have something useful to the user, even if it's not complete

There is a third category; those with demanding needs who want to build their own software. The first thing I'd say here is to look carefully at using tools. I've seen more than one project get sucked into a long exercise at building frameworks, which wasn't what the project was really about.

In case you haven't realized it, building computer systems is hard. As the complexity of the system gets greater, the task of building the software gets exponentially harder


architecture
------------

architecture
- highest-level breakdown of a system into its parts
- decisions that are hard to change

In this posting he brought out the point that
architecture is a subjective thing, a shared understanding of a system's design by the expert developers on a
project. Commonly this shared understanding is in the form of the major components of the system and how
they interact. It's also about decisions, in that it's the decisions that developers wish they could get right
early on because they're perceived as hard to change. The subjectivity comes in here as well because, if you
find that something is easier to change than you once thought, then it's no longer architectural. In the end
architecture boils down to the important stuff—whatever that is.

"The architectural pattern I like the most is that of layers"

"This book is about how you decompose an enterprise application into layers and how these layers work together"


Enterprise Applications
-----------------------

Enterprise applications often have complex data—and lots of it—to work on, together with business rules that fail all tests of logical reasoning.

Then there's the matter of what comes under the term "business logic." I find this a curious term because there are few things that are less logical than business logic. 

When you build an operating system you strive
to keep the whole thing logical. But business rules are just given to you, and without major political effort
there's nothing you can do to change them. You have to deal with a haphazard array of strange conditions
that often interact with each other in surprising ways. Of course, they got that way for a reason: Some
salesman negotiated to have a certain yearly payment two days later than usual because that fit with his
customer's accounting cycle and thus won a couple of million dollars in business. A few thousand of these
one-off special cases is what leads to the complex business "illogic" that makes business software so
difficult. In this situation you have to organize the business logic as effectively as you can, because the only
certain thing is that the logic will change over time.

Indeed, one of the best things you can do is turn a large project into a small one by simplifying its architecture and process.

For me much of the challenge (and interest) in design is in knowing about alternatives and judging the trade-offs of using one alternative over another

know the alternatives


Performance
-----------

For most performance issues I prefer to get a system up and running, instrument it, and then use a disciplined optimization process based on measurement.

response time:
- amount of time it takes to process a request from the outside.

responsiveness:
- how quickly the system acknowledges a request as opposed to processing it.
- response time may be good but responsiveness bad, users will be mad

latency:
- the minimum time required to get any form of response, even if the work to be done is
nonexistent.

throughput:
- how much stuff you can do in a given amount of time.
- for enterprise software a typical measurement is transactions per second

performance: throughput or response time

load:
- a statement of how much stress a system is under

load sensitivty:
- how the response time varies with the load

efficiency:
- performance divided by resources
- for example: system that gets 30 tps on 2 cpu's is more efficient than system that gets 40 tps on 4 cpu's

capacity of a system:
- indication of maximum effective throughput or load
- might be an absolute maximum or a point at which the performance dips below an acceptable threshold.

scalability:
- measure of how adding resources (usually hardware) affects performance


Patterns
--------

"Each pattern describes a problem which occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice" [Alexander et al.]. Alexander is an architect, so he was talking about buildings, but the definition works pretty nicely for software as well.

I like to say that patterns are "half baked," meaning that you always have to finish them off in the oven of your own project. 


Layering
--------

example:
ftp on top of tcp on top of ip on top of ethernet

lower layers unaware of higher layers

layers hide the layers beneath them

layering benefits:
- understand a single layer as a coherent whole without knowing much about the other layers
- substitute layers with alternate implementations
- minimize dependencies between layers
- good place to standardize
- once a layer is built, you can use it for many higher level services

layering downsides:
- layers encapsulate some but not all
- extra layers can harm performance

object community moved to a 3 layer system:
- presentation layer for UI
- domain layer for domain logic
- a data source

tier usually implies physical separation

client/server systems:
- two tier sytem
- physical separation
- client = desktop app, and server
- distinct layer of domain logic oftens runs on either a desktop or database server


Three principal layers
----------------------

presentation
domain
data source

presentation logic: how to handle the interaction between the user and the software
domain logic: logic that is the real point of the system. business logic.
data source logic: carrying out tasks on behalf of the application. communication with databases, messaging systems, transaction managers

Alistair Cockburn's Hexagonal Architectural Pattern
- visualizes any system as a core surrounded by interfaces to external systems.
- In Hexagonal Architecture everything external is fundamentally an outside interface, and thus it's a symmetrical view rather than my asymmetric layering scheme.

Alternative name: ‘’Hexagonal Architecture’’
Intent
Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases.

interface that you provide as a service and your use of someone else's service:
I think there is a good distinction to be made between an
interface that you provide as a service to others and your use of someone else's service. Driving down to the
core, this is the real distinction I make between presentation and data source. Presentation is an external
interface for a service your system offers to someone else, whether it be a complex human or a simple
remote program. Data source is the interface to things that are providing a service to you. I find it beneficial
to think about these differently because the difference in clients alters the way you think about the service.

separation:
- a steady rule about dependencies: domain and data source should never be dependent on the presentation
- makes it easier to substitute different presentation layers

RULE: what is domain logic & what is other forms of logic?
-  imagine adding a radically different layer to an application, such as a command-line interface to a Web application. If there's any functionality you have to duplicate in order to do this, that's a sign of where domain logic has leaked into the presentation.

EXAMPLE:
- system contained a list of products
- all products that sold over 10 percent more than they did the previous month were colored red
- developers placed the logic in the presentation layer that compared this month to last, and highlighted it red
- ^^ that's putting business logic in the presentation layer
- to properly separate layers, need a method in the domain layer to indicate if a product is improving sales -> returns bool -> presentation layer colors red based on the bool


Choosing where to run your layers
---------------------------------

logical layers:
- dividing a system into separate pieces to reduce the coupling between different parts of a system

data source: most always runs only on servers
- exception: disconnected client, must have data source. must be synchronized.

presentation layer: runs on client (desktop app, web ui) or server (web ui)

domain logic: can run all on server, all on client, or hybrid

complexity boosters: distribution, explicit multithreading, paradigm chasms, multiplatform development, extreme performance requirements


Ch 3: Mapping to Relational Databases
=====================================

data source layer role:
- communicate with the various pieces of infrastructure that an application needs to do its job

Architectural Patterns
----------------------

drive the way in which the domain logic talks to the database
- difficult to refactor
- stronglt affected by how you design your domain logic

sql:
- separate sql acess from the domain logic and place it in separate classes
- one class per database table
- these classes form a Gateway to the table

two main ways in which you can use a Gateway:
- instance of it for each row that's returned by a query: Row Data Gateway
- Record Set

Row Data Gateway: one instance per row returned by a query
Table Data Gateway: one instance per table
- fits nicely with Record Set and Table Module

"I find the clear separation of SQL and domain logic to be very helpful"

in simple applications:
- domain model is uncomplicated structure that corresponds closely to database structure
- one domain class per database table

Active Record:
- each domain object is responsible for loading and saving from the database

Domain Mapper:
- insulates the domain objects and the database from each other
- indirection layer entirely responsible for the mapping between domain objects and database tables
- handles all loading and storing between the db and the domain model
- allows both to vary independently
- complete isolation between the two layers

"persistence mechanism" - how you save the data in some kind of in-memory model to the database

table: represents a "tabular" data structure

Interesting: OO Databases

consider buying an O/R mapping tool if you have a domain model.

jdo: https://db.apache.org/jdo/
- java data objects, OO persistence


The Behavioral Problem
----------------------

"when people talk about O/R mapping, they usually focus on the structural aspects - how you relate tables to objects"

behavioral problem: how to get the various objects to load and save themselves to the database
- obvious route: load and save methods

*Unit of Work*: aimed at solving behavioral problem. keeps track of all objects read from the database, together with all objects modified in any way. Also handles how updates are made to the database.
- essential pattern whenever the behavioral interactions with the database become awkward
- think of it as an object that acts as the controller of the database mapping


Reading in Data
---------------

finder methods work on database state not object state

performance issues of reading in data, two rules:
- try to pull back multiple rows at once
- NEVER do repeated queries on the same table to get multiple rows
- it's usually better to use on query that brings back unnecessary rows than to issue N individual queries
- use joins: 3-4 joins per query max, beyond that, performance suffers


Structural Mapping Patterns
---------------------------

When people talk about object-relational mapping, they mostly mean structural mapping patterns: mapping in memory objects and database tables.


Mapping Relationships
- central issue: how objects and relations handle links
- objects: handle links by storing references that are held by the runtime
- relational database: handl links by forming a key into another table

The way to handle the representation problem is to keep the relational identity of each object as an Identity
Field (216) in the object, and to look up these values to map back and forth between the object references
and the relational keys. It's a tedious process but not that difficult once you understand the basic technique.
When you read objects from the disk you use an Identity Map (195) as a lookup table from relational keys to
objects. Each time you come across a foreign key in the table, you use Foreign Key Mapping (236) (see
Figure 3.5) to wire up the appropriate inter-object reference. If you don't have the key in the Identity Map
(195), you need to either go to the database to get it or use a Lazy Load (200). Each time you save an
object, you save it into the row with the right key. Any inter-object reference is replaced with the target
object's ID field.

Use a *Foreign Key Mapping* to map a single valued field
Use a *Foreign Key Mapping* to map a collection field
Use an *Association Table Mapping* to map a many-to-many association

referential integrity

Hierarchic structures such as org charts and bills of materials are where a Serialized LOB (272) can save a lot of database roundtrips
- The downside is that SQL isn't aware of what's happening, so you can't make portable queries against the data structure.



Inheritance
-----------

relational problems:
- compositional hierarchies
- class hierarchies linked by inheritance

for any inheritance structure, there are basically three options:
- one table for all classes in the hierarchy: *Single Table Inheritance*
- one table for each concrete class: *Concrete Table Inheritance*
- one table per class in the hierarchy: *Class Table Inheritance*
- trade offs are between duplication of data structure and speed of access

Single Table Inheritance:
- uses one table to store all the classes in a hierarchy
- biggest downside: wasted space, since each row has to have columns for all possible subtypes and this leads to empty columns
- many databases do a great job at compressing wasted table space
- size can be a bottleneck
- advantage: puts all stuff in one place
- avoids joins 
- easy to do
- author's first choice - easy & resilient to many refactorings

Concrete Table Inheritance:
- uses one table to store each concrete class in a hierarchy
- avoids the joins, allowing you to pull a single object from one table
- brittle to changes
- with any change to a super class, you have to remember to alter all the tables (and the mapping code)

Class Table Inheritance:
- uses one table for each class in a hierarchy
- simplest relationship between classes and tables
- but, needs multiple joins to load a single object


Building the mapping
--------------------

When you map to a relational database, essentially three situations you encounter:
- choose schema yourself
- have to map an existing schema, which can't be changed
- have to map an existing schema, but changes to it are negotioable


Using Metdata
-------------

*Metadata Mapping*
- based on boiling down the mapping into a metadata file that details how columns in the database map to fields in object
- uses code generation or reflective programming


Database Connections
--------------------

queries on a connection return a *Record Set*
- can be connected or disconnected
- transactions usually need to stay open

usually worthwhile to create a connection pool
- request a connection from the pool and release it when done
- often pools are put behind an interface that looks like creating a new connection. that way you don't know whether or not you're getting a brand new connection or one allocated from the pool.
- pooling should be properly encapsulated
- closing a connection may just release a connection back to the pool

to ensure that you have a connection where you need it, two choices:
- pass the connection around as an explicit parameter: gets ugly
- bring out a *Registry*
- use a thread-scoped *Registry*

connections are usually tied to transactions
- a good way to manage them is to tie them to a transaction
- open them when you begin a transaction, close them on commit or roll back
- *Unit of Work* makes a natural fit to manage both the transaction and connection


Misc Points
-----------

not wise to use select *
- can break if columns are added or removed

As a result it's usually worth having simple create/read/update/delete test cases for each database mapping structure you use. 

try and use precompiled SQL queries
dynamic SQL queries are slow
batch SQL queries into a single database call



Ch4: Web Presentation
=====================

MVC
---

*Model View Controller*
- script for request interpretation
- server page for response formatting
- controller should be called "input controller"
- controller handles the request, gets the model to do the domain logic, and then gets the view to create a response based on the model
- most important reasn for MVC: to ensure that the models are completely separated from the Web presentation

mvc flow:
- request comes in to an input controller
- input controller pulls info off the request
- forwards the business logic to an appropriate model object
- model object talks to the data source and does everything as well as gather info for the response
- when model is done, returns control to the input controller
- input controller looks at the results and decides which view is needed to display the response
- then passes control, together with the response data, to the view

*Application Controller*:
- manages the order of screens etc
- handle the "flow" of an application
- separate layer that may exist between the presentation and domain layers
- a good test is this: if the machine is in control of the screen flow, you need an *Application Controller*; if the user is in control, you don't.


View Patterns
-------------

view patterns:
- *Transform View*
- *Template View*
- *Two Step View*
- two choices: whether to use or transform view or template view and whether or not they are one or two step.

*Template View*
- allows you to write the presentation in the structure of the page and embed markers into the page to indicate where dynamic content needs to go
- can be very messy
- keep programming logic out of the page structure

*Transform View*
- popular: xslt
- input controller picks the appropriate xslt stylesheet and applies it to XML gleaned from a model

*Single Stage View*
- has only one view component for each screen
- view takes domain oriented data and renders it in html

*Two Stage View*
- produces a logical screen from the domain data and then rendering it in html
- advange: puts decision of what html to use in a single place


Input Controller Patterns
-------------------------

Two patterns for the input controller:
- *Page Controller*
- *Front Controller*

With any input controller, two responsibilities:
- handling the HTTP request and deciding what to do with it



Ch5: Concurrency
================

most devs don't worry about concurrency because of: transcations and transaction managers

offline concurrency:
- concurrency control for data that's manipulated during multiple database transactions

"After all, if you aren't familiar with source code control systems, you really shouldn't be developing enterprise applications."

lost updates

inconsistent read: occurs when you read two things that are correct pieces of info but not correct at the same time

liveness: how much concurrent activity can go on
- sometimes need to sacrifice correctness to gain more liveness


Execution Contexts
------------------

from the perspective of interacting with the outside world, two important contexts:
- request
- session

request: corresponds to a single call from the outside world which the software works on and optionally sends back a response

session: long running interaction between a client and a server
- commonly consists of a series of requests
- user regards as consistent logical sequence

os perspective contexts:
- process
- thread

database context:
- transaction

transactions:
- system transaction: application to database
- business transaction: user to application

isolation: partition data so that any piece of it can only be accessed by one active agent
- sharing memory is an issue
- arrange things so the programs enters an isolated zone, don't have to worry about concurrency
- good concurrency design is thus to find ways of creating such zones -> ensure as much programming as possible is done in them

immutable data:
- "you only get concurrency problems if the data you're sharing can be modified"
- immutable almost all the time
- another option: separation applications that are only reading data, have them use copied data sources


Optimistic and Pessimistic Concurrency Control
----------------------------------------------

when we have mutable data that we can't isolate -> two forms of concurrency control:
- optimistic: about conflict detection
- pessimistic: about conflict prevention

most source code control systems use optimistic concurrency control.

optimistic locks:
- usually base their conflict detection on some kind of version marker on the data: timestamp, sequence counter

pessimistic locks:
- reduce concurrency

when to choose:
- optimistic: if conflicts are rare or if the consequences are no big deal
- pessimistic: if conflicts are painful for users, consequences are a big deal

inconsistent reads:
- a way to deal with them: temporal reads

deadlocks:
- big problem for pessimistic locks
- give every lock a time limit? eek


Transactions
------------

primary tool for handling concurrency in enterprise applications: transaction

transaction:
- bounded sequence of work
- start and endpoints well defined
- must complete on an all-or-nothing basis

ACID
- atomicity: each step in the sequence of actions performed within the boundaries of a transaction must complete successfully or all work must be rolled back.
- consistency: noncorrupt state at both the start and end of a transaction
- isolation: result of an individual transaction must not be visible to any other open transactions until that transaction commits successfully
- durability: any result of a committed transaction must be made permanent. must survive crash.



Transactional Resources
-----------------------

transactional resource: anything that's transactional
- uses a transaction to control concurrency
- keep transactions as short as possible
- transactions shouldn't span multiple requests (long transaction)


IMP
When you use transactions, you need be somewhat aware of what exactly is being locked. For many database actions the transaction system locks the rows involved, which allows multiple transactions to access the same table. However, if a transaction locks a lot of rows in a table, then the database has more locks than it can handle and escalates the locking to the entire table—locking out other transactions. This lock escalation can have a serious effect on concurrency, and it's particularly why you shouldn't have some "object" table for data at the domain's Layer Supertype (475) level. Such a table is a prime candidate for lock escalation, and locking that table shuts everybody else out of the database.  


SQL defines four levels of isolation:
- serializable: strongest level (to be sure of correctness, always use this level, may mess up liveness)
- repeatable read: allows phantoms
- read committed: allows unrepeatable reads
- read uncommitted: allows dirty reads
phantoms: occur when you add some elements to a collection and the reader sees only some of them

AVOID LONG TRANSACTIONS


Patterns for Offline Concurrency Control
----------------------------------------

IMP

As much as possible, you should let your transaction system deal with concurrency problems.

Remember that these are techniques you should only use if you have to. If you can make all your business transactions fit into a system transaction by ensuring that they fit within a single request, then do that. If you can get away with long transactions by forsaking scalability, then do that. By leaving concurrency control in the hands of your transaction software you'll avoid a great deal of trouble.

offline concurrency:
- *Optimistic Offline Lock*
- *Pessimistic Offline Lock*

Optimistic Offline Lock:
- optimistic concurrency control across the business transactions.
- easier approach
- yields the best liveliness
- find out when business transaction is going to fail when you try to commit it

Pessimistic Offline Lock:
- find out early if you're in trouble but lose out because it's harder to program and it reduces liveness

Coard-Grained Lock:
- allows you to manage concurrency of a group of objects together

Implicit Lock:
- avoids developers from having to manage locks directly


IMP

A common statement about concurrency is that it's a purely technical decision that can be decided on after requirements are complete. We disagree. The choice of optimistic or pessimistic controls affects the whole user experience of the system. 


Application Server Concurrency
------------------------------

application server itself:
- how does it handle multiple requests concurrently?
- how does affect the design of the server?
- doesn't involve transactions
- explicit multithreaded programming with locks and synchronization blocks is complicated and easy to introduce defects that are very hard to find.

concurrency bugs are almost impossible to reproduce.

approaches:
- process-per-session
- process-per-request
- pooled process-perprequest
- thread-per-request

process-per-request: limits damage

if you use thread-per-request:
- most important thing: enter isolated zones

avoid static class-based variables or global variables:
- any use of these has to be synchronized
- also true of singletons


IMP

If you need some kind of global memory, use a *Registry*
- thread specific storage



Ch6: Session State
==================

